\renewcommand{\documentname}{Proposed solution}

\chapter{Proposed solution}


\section{Search space}


\subsection{Assignments}

An assignment is a tuple which associates a group with a classroom.

\begin{equation}
    \scalebox{1.5}{$(G_{i}, C_{j})$}
\end{equation}

Because a group can only have \textit{one} classroom assigned, an assignment can be identified by the \textit{code} \footnote{The name convention previously mentioned: \textit{subject.type.name} (e.g. Com.T.1).} of the group. For example, the assignment for group SI.T.1 can be identified by the code SI.T.1 as well.

Assigning just \textit{one} classroom to each group means that the total number of assignments is calculated by the following expression.

\begin{equation}
    \scalebox{1.2}{$TotalNumberOfAssignments = \left|G\right|$}
\end{equation}

This implies that there are as many assignments as the number of groups for the semester.

\subsection{Solutions}

A \textit{solution} for this problem is represented by a set of all the assignments must be performed for the semester. As presented in the previous section, the total number of assignments equals the total number of groups in that semester. So we have the next statement.

\begin{equation}
    Solution = \{ (G_{1}, C_{x}), (G_{2}, C_{y}), ..., (G_{m}, C_{z})) \}
\end{equation}

Where $m$ is the total number of groups and $x$, $y$ and $z$ are the index for the classrooms assigned to the groups. Note that the classrooms are not sequential (e.g $x$ could represent $C_{12}$ and $y$ represent $C_{3}$).

An \textit{empty solution} is represented by a set of all the assignments where each assignment is \textit{incomplete}. We mean that an assignment is incomplete when the group has no classroom assigned.

\begin{equation}
    IncompleteAssignment = (G_{i}, -)
\end{equation}

So, for the empty solution, we have a set with the following format.

\begin{equation}
    EmptySolution = \{ (G_{1}, -), (G_{2}, -), ..., (G_{m}, -)) \}
\end{equation}

Finally, a \textit{partial solution} is one in which not every assignment was performed, and a \textit{complete solution} is defined by a set in which all the assignments have been performed and each group has a classroom associated with it.

\subsection{States}

A \textit{state} represents a phase in the problem. There can be three states. The \textit{initial state}, which stands for the empty solution of non allocated assignments. The \textit{final state}, which represents a complete solution with all the assignments performed. And the \textit{intermediate states} portraying partial solutions.

A key concept to understand our solution is the following. Although by default we start the execution of the algorithms with an initial state, it is also possible to start the execution with an intermediate state. This is because we can receive as input a partial or total solution of assignments and work from there. Now we will discuss how we can jump from one state to the next, which is normally called \textit{state expansion}.

To expand a state, one of the non performed assignments in the solution is executed. This means that every time a classroom is assigned to a group the state is being expanded. To perform an assignment, the number of possible candidates is the same as the number of classrooms. So we have the following.

\begin{equation}
    \scalebox{1.2}{$TotalNumberOfCandidates = \left|C\right|$}
\end{equation}

Nevertheless, as there exist constraints that indicate wether or not the solution is valid, there are filters which reduce the number of available classrooms for a group. This allows for optimized and easy to retrieve calculations in the execution of the greedy algorithm (this will be explained later in \ref{classroom-filters}). The important thing to note at this moment is that, because of these filters, not all states can be expanded.

\subsection{Instances}

The complexity of the calculations and completion time depend on many factors. Some of those factors follow. First, the number of groups for the semester, which directly translates to the number of assignments to be made. Second, the number of classrooms. If there are more classrooms, it is easier to avoid collisions. Obviously, the number of groups is much more volatile between semesters than the number of classes, which is likely to change very occasionally, if at all. Lastly, the case of starting the prototype with an intermediate state. This means that the set of assignments represents a partial solution given as input. The number of calculations decreases in direct proportion to the assignments already made, therefore the completion time would be lower.

Because of the constraints of the problem, there are some groups where class allocations are more straightforward. For example, a group with only one positive restriction is either going to have that classroom assigned to it or, if it collides with other group, end up unallocated. This is why all the groups that just have one available classroom are assigned first. Also, the groups which have less students have more available classrooms than those with a large number of members.



\section{Collisions}

A collision is an overlap of the timetable of two different groups. For a collision to occur, the groups must clash at least once in the same week, day and time. Collisions are an essential part of this problem, as we cannot assign a classroom to a group if another group was previously associated with that classroom and both groups collide.

\subsection{Lazy Collision Matrix}

Due to the large number of assignments that have to be made throughout the execution cycle of the genetic algorithm, the chosen data structures were properly analysed. This is where the \textit{Lazy Collision Matrix} comes in.

Imagine that we have the following group set.

\begin{equation}
    G = \{ G_{1}, G_{2}, G_{3} \}
\end{equation}

Then, our initial Lazy Collision Matrix would be represented by the expression below.

\begin{equation}
    LCM = \bordermatrix{
        & G_{1} & G_{2} & G_{3} \cr
        G_{1} &  & -1 & -1 \cr
        G_{2} & -1 &  & -1 \cr
        G_{3} & -1 & -1 & 
    } \qquad
\end{equation}

First of all, the diagonal is empty because we never compare one group against itself. Then, we can observe that the rest of values are defaulted to $-1$. Why? Because there are \textit{not yet evaluated}. That is the reason behind the name of the matrix. It is \textit{lazy} because the collisions are only calculated when needed.

Continuing with this example, imagine that we assign classroom $C_{x}$ to group $G_{1}$. Then, $G_{2}$ also tries to have $C_{x}$ assigned to it, so we check if both groups collide. We find out that they do, so we update the matrix.

\begin{equation}
    LCM = \bordermatrix{
        & G_{1} & G_{2} & G_{3} \cr
        G_{1} &  & 1 & -1 \cr
        G_{2} & 1 &  & -1 \cr
        G_{3} & -1 & -1 & 
    } \qquad
\end{equation}

Therefore, the values are updated with a $1$, which indicates that both groups \textit{collide}. This results in a different classroom $C_{y}$ being assigned to $G_{2}$. Now, $G_{3}$ has that classroom also available, so we check if it clashes with $G_{2}$. We learn that they do not collide. We update the matrix again.

\begin{equation}
    LCM = \bordermatrix{
        & G_{1} & G_{2} & G_{3} \cr
        G_{1} &  & 1 & -1 \cr
        G_{2} & 1 &  & 0 \cr
        G_{3} & -1 & 0 & 
    } \qquad
\end{equation}

The value for non-collision is $0$, as observed. Because $G_{3}$ does not clash with $G_{2}$, they are both allocated in the same classroom.

We can now generalise the LCM as in the next expression.

\begin{equation}
    LCM = \bordermatrix{
        & G_{1} & G_{2} & G_{3} \cr
        G_{1} &  & g_{12} & g_{13} \cr
        G_{2} & g_{21} &  & g_{23} \cr
        G_{3} & g_{31} & g_{32} & 
    } \qquad
\end{equation}

Where a value $g_{ij}$ can be $-1$ if the collision has not yet been evaulated, $0$ if groups $i$ and $j$ do not collide, and $1$ if they do collide.

The main advantage of this design is that we do not have to calculate all collisions. For example, a collision between a laboratory group and a theory group would be pointless to calculate because they would never be allocated in the same classroom. Therefore we aliviate the number of calculations. 

As there is only one Lazy Collision Matrix, all calculations performed by the greedy algorithm across all populations in all generations are stored in just one place. This means that all collisions are being calculated only when necessary and only once. Think of the previous example. In a future iteration the greedy algorithm wants to check if groups $G_{1}$ and $G_{2}$ collide. It access the corresponding location in the LCM, and because it contains a $1$, the greedy concludes that they indeed collide. This is done with a $O(1)$ complexity, as the matrix is coded as a dictionary of dictionaries. If instead the greedy wanted to check if groups $G_{1}$ and $G_{3}$ collided, because the LCM has a $-1$ in that position, the greedy would have to perform the collision check and then update the matrix.



\section{Classroom filters}\label{classroom-filters}


\subsection{What is a classroom filter}

\subsection{Lazy Filter Dictionary}



\section{Greedy algorithm}


\subsection{Preprocessing}

\subsection{Heuristic}

\subsection{Repairs}



\section{Genetic algorithm}


\subsection{Fitness function}

\subsection{Operators}

\subsubsection{Selection}

\subsubsection{Crossover}

\subsubsection{Mutation}

\subsubsection{Tournament}

\subsection{Parameters}


