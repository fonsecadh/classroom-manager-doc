\renewcommand{\documentname}{Theoretical Aspects}

\chapter{Theoretical aspects}\label{theory}

A digital magazine Bootaku works with three freelancers. Dante, Virgil and Beatrice. Together they write a section about book reviews. Gathering data from previous sections, Bootaku wants to define and solve a problem of efficiently assign all reviews to the three critics so that the section gets the highest profit. For the assignments, Bootaku wants every book review to have one (and only one) associated freelancer. If a freelancer ends up with no reviews, the assignments are still valid if and only if the previous condition is met.


\section{Assignment problem}

The problem described before is an example of an assignment problem. It can be generalised with the following elements: 

\begin{description}
    \item A set of $n$ freelancers $f$
    \item A set of $m$ book reviews $r$
    \item An assignment matrix of $n \times m$ assignments $a_{fr}$ such that $a_{fr} = 0$ when freelancer $f$ is not assigned to book review $r$ and $a_{fr} = 1$ when freelancer $f$ is assigned to book review $r$.
    \item A profit matrix of $n \times m$ profits $p_{fr}$ which indicate the profit obtained when assigning freelancer $f$ to book review $r$ and that $p_{fr} \textgreater 0$.
    \item A valid solution is defined as a matrix of assignments where all the book reviews have a freelancer assigned to them and no book review has more than one associated freelancer.
\end{description}

The profit for all the assignments will then be:

\begin{equation}
    \scalebox{2}{$\sum_{f=1}^n \sum_{r=1}^m a_{fr} p_{fr}$}
\end{equation}

The optimal solution consists on having a set of assignments such that the sum of all the profits for the current assignments is maximised.

For example, imagine that for the next month's section, we have the following data. The information is represented by means of two sets: $F$ for the freelancers and $R$ for the reviews.

\begin{align}
    F &= \{ Dante, Virgil, Beatrice \} \\
    R &= \{ {Divina\ Commedia}, {El\ Quijote}, {Voyage\ au\ bout\ de\ la\ nuit}, {Todo\ modo} \}
\end{align}

Then, our assignments and profits will be represented by the $A$ and $P$ matrices.

\begin{equation}
    A = \bordermatrix{
        & DC & EQ & VN & TM \cr
        Dante & a_{11} & a_{12} & a_{13} & a_{14} \cr
        Virgil & a_{21} & a_{22} & a_{23} & a_{24} \cr
        Beatrice & a_{31} & a_{32} & a_{33} & a_{34} 
    } \qquad
\end{equation}

\begin{equation}
    P = \bordermatrix{
        & DC & EQ & VN & TM \cr
        Dante & p_{11} & p_{12} & p_{13} & p_{14}\cr 
        Virgil & p_{21} & p_{22} & p_{23} & p_{24}\cr 
        Beatrice & p_{31} & p_{32} & p_{33} & p_{34} 
    } \qquad
\end{equation}

Where each row represents a freelancer and each column represents a book review. So freelancer 1 is Dante, 2 is Virgil and 3 is Beatrice. The same goes for the book reviews. Book review 1 is \textit{Divina Commedia}, 2 is \textit{El Quijote}, 3 is \textit{Voyage Au Bout De La Nuit} and 4 is \textit{Todo Modo}.

Now, we are going to study valid and non-valid solutions. As we explained before, a solution is valid if every book review has a freelancer assigned to it, and no more than one.

We will analyse four sets of values for the A matrix:

\begin{align}
    A1 &= 
    \begin{bmatrix}
        1 & 0 & 0 & 0\\ 
        0 & 0 & 1 & 0\\ 
        0 & 1 & 0 & 1
    \end{bmatrix} \\
    A2 &= 
    \begin{bmatrix}
        0 & 0 & 0 & 0\\ 
        1 & 0 & 1 & 0\\ 
        0 & 1 & 0 & 1 
    \end{bmatrix} \\
    A3 &= 
    \begin{bmatrix}
        0 & 0 & 1 & 0\\ 
        0 & 0 & 0 & 1\\ 
        1 & 0 & 0 & 0 
    \end{bmatrix} \\
    A4 &= 
    \begin{bmatrix}
        0 & 1 & 1 & 0\\ 
        0 & 0 & 0 & 1\\ 
        1 & 1 & 0 & 0 
    \end{bmatrix}
\end{align}

From these matrices, we can deduce that $A1$ and $A2$ are valid solutions, because they have one freelancer for each book review. We are not concerned with a freelancer having no book reviews assigned. However, a book review without an associated freelancer represents a non-valid solution. That is precisely the case for $A3$, the book review for \textit{El Quijote} has not an assigned freelancer. In the case of $A4$, the fact that \textit{El Quijote} has two freelancers assigned makes it a non-valid solution.

Now, we will give values to the $P$ matrix in order to discuss possible optimal solutions. We will compare them with the assignment matrices $A1$ and $A2$

\begin{align}
    P1 &= 
    \begin{bmatrix}
        9 & 1 & 5 & 4\\ 
        2 & 8 & 14 & 2\\ 
        7 & 11 & 10 & 6
    \end{bmatrix} \\
    P2 &= 
    \begin{bmatrix}
        9 & 1 & 5 & 4\\ 
        13 & 8 & 14 & 2\\ 
        7 & 11 & 10 & 6
    \end{bmatrix}
\end{align}

$P1$ and $A1$:

\begin{equation}
    \scalebox{1.2}{$Profit = \sum_{f=1}^n \sum_{r=1}^m a_{fr} p_{fr} = 9 + 11 + 14 + 6 = 40$}
\end{equation}

$P1$ and $A2$:

\begin{equation}
    \scalebox{1.2}{$Profit = \sum_{f=1}^n \sum_{r=1}^m a_{fr} p_{fr} = 2 + 11 + 14 + 6 = 33$}
\end{equation}

We can observe that for $P1$, the assignments defined in $A1$ are better than those in $A2$, because they result in a better profit. Another important remark about $A1$ is that it is the optimal solution to the problem, because it assigns the book reviews to the freelancers with the best profit value for their assigned books. Now $P2$ will be evaluated.

$P2$ and $A1$:

\begin{equation}
    \scalebox{1.2}{$Profit = \sum_{f=1}^n \sum_{r=1}^m a_{fr} p_{fr} = 9 + 11 + 14 + 6  = 40$}
\end{equation}

$P2$ and $A2$:

\begin{equation}
    \scalebox{1.2}{$Profit = \sum_{f=1}^n \sum_{r=1}^m a_{fr} p_{fr} = 13 + 11 + 14 + 6 = 44$}
\end{equation}

In the case of the profits values of $P2$, the situation is reversed. $A2$ is now the optimal solution and therefore better than $A1$.

The important thing to notice here is that the values for the $P$ matrix right now may appear as having no meaning whatsoever. But we need to think of $P$ as the results obtained from a profit funtion. Then, we can interpret $P1$ as values of profit in a context where Virgil has just expressed an opinion on social media about the \textit{Divina Commedia} and caused a massive controversy. We can then say that $P1$ is a function which gives more importance to public relations and so the profit $p_{21}$ is very low, whereas $P2$ gives more importance to views and so the profit $p_{21}$ is higher. Of course, in a real problem you know what the function is calculating, but this shows how we can add meaning to a set of symbols in order to understand the data more efficiently.

With this, we have discussed an assignment problem, looked at its main components and analysed its non-valid, valid and optimal solutions. Some final remarks about the relation between a general assignment problem and the Bootaku problem follow. The actors that perform the jobs, in this case the freelancers that \textit{write} the reviews, are called the \textit{agents}. The \textit{tasks} to be performed are, in the Bootaku problem, the book reviews. Nevertheless, the agents in an assignment problem do not need to be persons (or even things that carry out actions), they can be machines, warehouses, or classrooms. The same can be said for the tasks.


\section{Greedy algorithms}

One way of solving the Bootaku problem described earlier can be found in \textit{greedy algorithms}. A greedy algorithm \cite{guerequetavallecillo98algdesign} will try to find a subset of candidates that meet the problem constraints and that form the optimal solution. To do so, the algoritm is run iteratively. In each iteration, it will select the best candidate for that precise moment, neglecting future consequences (that is why they are called \textit{greedy})\footnote{For example, let's say I'm walking down the street and I get thirsty. On my mental list of candidate drinks, water has a value of 5 points, lemonade 3 and tea 1. The first vending machine I come across on the street only sells lemonade and tea, so I buy lemonade. However, on the next street I find another vending machine that sells water, but as I am no longer thirsty I don't buy any more drinks. That is, I found a valid solution but not the optimal solution.}. Before adding a candidate to the solution, the algorithm will determine if it is promising. If the answer is yes, then the candidate is added to the solution. Otherwise, the candidate is no longer evaluated. Each time a candidate is added to the solution, the greedy checks whether the current solution is valid or not.

With this in mind, here follows the \textit{pseudocode} of the generic Greedy Algorithm.

\begin{algorithm}[H]
    \caption{Generic Greedy Algorithm}
    \begin{algorithmic}[1]
        \Procedure {GreedyAlgorithm}{candidates}
            \State {$x \gets \epsilon$} 
            \State {$solution\gets \{\}$}
            \State {$found\gets false$}
            \While {$\ !isEmpty(candidates)\ \text{ and } !found$}
                \State {$x\gets selectCandidate(candidates)$}
                \If {$\ isPromising(x,\ candidates)$}
                    \State {$addToSolution(x,\ solution)$}
                    \If {$\ isSolution(solution)$}
                        \State {$found\gets true$}
                    \EndIf
                \EndIf
            \EndWhile
            \State \textbf{return} $solution$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

As we can see, the generic greedy algorithm has a very simple and elegant definition. However, even though greedy algorithms are easy to implement and can obtain efficient solutions, they are not perfect. Their main flaw relies on their  selection function. It is difficult to design a function that can simultaneously find a good local result and translate it into a good global result. That is, the best candidate in some iteration may not be part of the optimal solution. 

Next, we will solve the Bootaku problem using a greedy algorithm. The greedy algorithm that we are going to use is inspired by the one defined in \cite{guerequetavallecillo98algdesign} for solving the \textit{Assignment of tasks} problem.

\begin{algorithm}[H]
    \caption{Greedy Algorithm for the Bootaku problem}
    \begin{algorithmic}[1]
        \Procedure {GreedyBootaku}{profits, assignments}
            \State {$best \gets \epsilon$}
            \For {$\ \text{each freelancer } F_{i} \in F$}
                \For {$\ \text{each review } R_{j} \in R$}
                    \State {$assignments[F_{i},\ R_{j}] = false$} \Comment{We initialise the assignments matrix (to false or cero, it does not matter)}
                \EndFor
            \EndFor
            \For {$\ \text{each review } R_{j} \in R$}
                \State {$best \gets bestFreelancerFor(profits,\ assignments,\ R_{j})$}
                \State {$assignments[best,\ R_{j}] = true$} \Comment{Again, it can be true or one, depending on the implementation}
            \EndFor
            \State \textbf{return} $assignments$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{bestFreelancerFor procedure for the Bootaku problem}
    \begin{algorithmic}[1]
        \Procedure {bestFreelancerFor}{profits, assignments, review}
            \State {$best \gets \epsilon$} 
            \State {$min\gets \text{maximum integer value}$}
            \For {$\ \text{each freelancer } F_{i} \in F$}
                \If {$\ profits[F_{i},\ review] < min$}
                    \State {$min \gets profits[F_{i},\ review]$}
                    \State {$best \gets F_{i}$}
                \EndIf
            \EndFor
            \State \textbf{return} $best$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

Those are the two procedures needed in order to solve the Bootaku problem. In the \textit{Assignments of tasks} problem described in the book, the authors define an extra function that checks if the worker is already assigned to another task. However, because our problem is not balanced (we have a different number of tasks and agents), it means that we can have a freelancer writing more than one book review, so that extra function is not required.

The Bootaku problem is really simple to solve because of its lack of constraints. This is done deliberately to focus more on the components of assignment problems and to not waste time on explaining difficult restrictions. However, most problems, including the real problem this document defines (to assign classrooms to the groups of the School), have a lot of constraints. 

One way to complicate the Bootaku problem would be to assign completion times to each review. We would have a $n \times m$ $T$ matrix with the completion times for all freelancers and reviews.

\begin{equation}
    T = \bordermatrix{
        & DC & EQ & VN & TM \cr
        Dante & t_{11} & t_{12} & t_{13} & t_{14} \cr
        Virgil & t_{21} & t_{22} & t_{23} & t_{24} \cr
        Beatrice & t_{31} & t_{32} & t_{33} & t_{34} 
    } \qquad
\end{equation}

Then we could have a maximum time per freelancer. This would force the greedy algorithm to perform a check before assigning a review to a freelancer. If the time it takes to write the review surpases the maximum time available for that freelancer, the assignment cannot be made. 

Let's say that Beatrice has been assigned to the book review for \textit{El Quijote}, so she has already spent a total time of $t_{32} \leq maxTime$. In a future iteration the greedy algorithm evaluates Beatrice for reviewing \textit{Todo Modo}. Even if she has the greatest profit for \textit{Todo modo}, it is still not enough. The greedy algorithm first has to check in the $bestFreelancerFor$ procedure if $t_{32} + t_{34} \leq maxTime$ and, if the condition is true, then the assignment is performed. 

We can notice in the Beatrice example the main failure of greedy algorithms. She was assigned to \textit{El Quijote} for a profit $p_{32}$ and then evaluated again for \textit{Todo modo} with a profit $p_{34}$. Imagine that she has not enough time left to be able to review the second book and that $p_{34}$ is \textit{way bigger} than $p_{32}$. This is where assigning the best local result $a_{32}$ would end up ruling out the possibility of assigning the better global result $a_{34}$.



\section{Heuristics and metaheuristics}

Search strategies in a search problem can be \textit{informed} or \textit{uninformed}. Informed strategies use knowledge specific to a given problem but that is outside of its definition, making this type of strategies more efficient than uninformed strategies. The main way of applying our knowledge of a given problem into the search algorithm designed to solve said problem is by means of \textit{heuristic functions}. An heuristic function $h(n)$ \cite{russellnorvig10ai} represents an estimation of the minimum cost of getting to the objective state from the state given by node $n$. To expand a node, the algorithm also makes use of an \textit{evaluation function}. An evaluation function $f(n)$ analyses the non-expanded nodes and selects the one with the lowest cost. In the case of greedy algorithms, the evaluation function of a node n is equivalent to the heuristic function of the same node. So we have that $f(n) = h(n)$.

Now that we have explained what heuristic functions are, one question remains. What are \textit{metaheuristics}? Analysing the word, one could think that the \textit{meta} prefix implies that metaheuristics are \textit{heuristics about heuristics}, in the same way \textit{metadata} is \textit{data about data}. However, as Luke \cite{luke13metaheuristics} points out, this is not the case at all. He defines metaheuristics as:

\begin{displayquote}
    ... a rather unfortunate term often used to describe a major subfield, indeed the primary subfield, of \textbf{stochastic optimization}. Stochastic optimization is the general class of algorithms and techniques which employ some degree of randomness to find optimal (or as optimal as possible) solutions to hard problems. Metaheuristics are the most general of these kinds of algorithms, and are applied to a very wide range of problems.
\end{displayquote}

There are many methods of designing algorithms based on \textit{metaheuristics}. In this project we will focus on the Evolutionary Computation method, a subtype of Population-based methods.


\subsection{Evolutionary Computation}

Evolutionary Computation (EC) \cite{luke13metaheuristics} takes inspiration from population biology, genetics and evolution \footnote{Because this method uses vocabulary from these fields of biology, we have followed Luke's approach and defined these terms one by one. A list of definitions of the most commonly used terms in EC has been created in the annex of definitions and abbreviations.}. We are interested in the types of algorithms designed using this method, known as Evolutionary Algorithms (EAs). An EA may be (most of the times) either a \textit{generational algorithm} or a \textit{steady-state algorithm}.  A generational algorithm creates a new population of individuals, based on the previous one, in each iteration. Moreover, a steady-state algorithm changes a subset of individuals in each iteration, but not the entire population. The most common EAs are the \textit{Genetic Algorithms} and the \textit{Evolution Strategies}, and there are generational and steady-state versions of the two.

Below is the pseudocode for an abstract generational algorithm.

\begin{algorithm}[H]
    \caption{Abstract Generational Algorithm}
    \begin{algorithmic}[1]
        \Procedure {AbstractGenerationalAlgorithm}{maxTime}
            \State {$P \gets \text{create the initial population}$} 
            \State {$best\gets \epsilon$}
            \State {$currentTime\gets \text{get current time}$}
            \While {$\ !idealSolution(P)\ \text{ and } currentTime \leq maxTime$}
                \State {$evaluate(P)$}\Comment{Calculate the fitness of all individuals}
                \For {$\ \text{each individual } P_{i} \in P$}
                    \If {$\ best = \epsilon \text{ and } Fitness(P_{i}) > Fitness(best)$}
                        \State {$best\gets P_{i}$}
                    \EndIf
                \EndFor
                \State {$P\gets newGeneration(P,\ breed(P))$}
                \State {$currentTime\gets \text{update time}$}
            \EndWhile
            \State \textbf{return} $best$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

The initial population in this kinds of algorithms is created by adding random individuals to a set until the maximum population size is reached. Some good practices for this process follow. The most important thing is not generating repeated individuals. This can be done with a dictionary in which we store the individuals as keys. For every new randomly generated individual we check if it is not already contained in said dictionary before adding it to the population set. Finally, it is possible to include individuals designed by hand into the initial population (this is called \textit{seeding} the population). However, the use of EAs already implies that finding a good heuristic for the problem is not trivial. So even if we think that the individuals we design may be going in the right direction, it is very likely that they will end up producing poor results.

The main difference between generational EAs relies on how they create the new generation. This process is done by means of different operations such as \textit{selection}, \textit{crossover} and \textit{mutation}. Also, some EAs simply discard all the parents in the new generation and others include them again if they have an acceptable fitness. We will take a look at two specific EAs in the following sections, Evolution Strategies and Genetic Algorithms.


\subsection{Evolution Strategies}


\subsection{Genetic algorithms}



